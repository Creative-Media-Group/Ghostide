import antlr4 from 'antlr4'; import ANTLRv4Lexer from './ANTLRv4Lexer.js'; export default class LexerAdaptor extends antlr4 . Lexer { constructor (input) { super (input); this . PREQUEL_CONSTRUCT = - 10; this . OPTIONS_CONSTRUCT = - 11; this . _currentRuleType = antlr4 . Token . INVALID_TYPE; this . insideOptionsBlock = false; } getCurrentRuleType () { return this . _currentRuleType; } setCurrentRuleType (ruleType) { this . _currentRuleType = ruleType; } handleBeginArgument () { if (this . inLexerRule ()) { this . pushMode (ANTLRv4Lexer . LexerCharSet); this . more (); } else { this . pushMode (ANTLRv4Lexer . Argument); } } handleEndArgument () { this . popMode (); if (this . _modeStack . length > 0) { this . _type = ANTLRv4Lexer . ARGUMENT_CONTENT; } } handleEndAction () { var oldMode = this . _mode; var newMode = this . popMode (); var isActionWithinAction = this . _modeStack . length > 0 && newMode == ANTLRv4Lexer . TargetLanguageAction && oldMode == newMode; if (isActionWithinAction) { this . _type = ANTLRv4Lexer . ACTION_CONTENT; } } emit () { if ((this . _type == ANTLRv4Lexer . OPTIONS || this . _type == ANTLRv4Lexer . TOKENS || this . _type == ANTLRv4Lexer . CHANNELS) && this . getCurrentRuleType () == antlr4 . Token . INVALID_TYPE) { this . setCurrentRuleType (this . PREQUEL_CONSTRUCT); } else if (this . _type == ANTLRv4Lexer . OPTIONS && this . getCurrentRuleType () == ANTLRv4Lexer . TOKEN_REF) { this . setCurrentRuleType (this . OPTIONS_CONSTRUCT); } else if (this . _type == ANTLRv4Lexer . RBRACE && this . getCurrentRuleType () == this . PREQUEL_CONSTRUCT) { this . setCurrentRuleType (antlr4 . Token . INVALID_TYPE); } else if (this . _type == ANTLRv4Lexer . RBRACE && this . getCurrentRuleType () == this . OPTIONS_CONSTRUCT) { this . setCurrentRuleType (ANTLRv4Lexer . TOKEN_REF); } else if (this . _type == ANTLRv4Lexer . AT && this . getCurrentRuleType () == antlr4 . Token . INVALID_TYPE) { this . setCurrentRuleType (ANTLRv4Lexer . AT); } else if (this . _type == ANTLRv4Lexer . SEMI && this . getCurrentRuleType () == this . OPTIONS_CONSTRUCT) { } else if (this . _type == ANTLRv4Lexer . END_ACTION && this . getCurrentRuleType () == ANTLRv4Lexer . AT) { this . setCurrentRuleType (antlr4 . Token . INVALID_TYPE); } else if (this . _type == ANTLRv4Lexer . ID) { var firstChar = this . _input . getText (this . _tokenStartCharIndex , this . _tokenStartCharIndex); var c = firstChar . charAt (0); if (c == c . toUpperCase ()) { this . _type = ANTLRv4Lexer . TOKEN_REF; } else { this . _type = ANTLRv4Lexer . RULE_REF; } if (this . getCurrentRuleType () == antlr4 . Token . INVALID_TYPE) { this . setCurrentRuleType (this . _type); } } else if (this . _type == ANTLRv4Lexer . SEMI) { this . setCurrentRuleType (antlr4 . Token . INVALID_TYPE); } return super . emit (); } inLexerRule () { return this . getCurrentRuleType () == ANTLRv4Lexer . TOKEN_REF; } inParserRule () { return this . getCurrentRuleType () == ANTLRv4Lexer . RULE_REF; } reset () { this . setCurrentRuleType (antlr4 . Token . INVALID_TYPE); this . insideOptionsBlock = false; super . reset (); } }

